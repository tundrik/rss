## Инструкция

    $ git clone https://github.com/tundrik/rss
    $ cd rss
    $ make up

## REST HTTP

Все конечные точки требуют авторизации. 
В роли авторизации будет выступать uuid, который надо отправить в Header `X-Auth-ID`.

Роль администратора

    35be0a7c-8570-4987-be59-efeac5906d74

Роль пользователя

    093d7936-8c3e-4e36-aa4a-8fe2e820ea4f


| Url          | Method | Body                            |Description |
| :---         | :---   | :---                            |:--- |
| /            | `GET`  |                                 | **Получить** список доступных rss каналов |
| /subscribe   | `PUT`  | form urlencoded `feed_pk=`      | **Подписаться** на канал |
| /unsubscribe | `PUT`  | form urlencoded `feed_pk=`      | **Отписаться** от канала |
| /article     | `GET`  |                                 | **Получить** список статей с каналов на каторые подписан пользователь |
| /add         | `POST` | form urlencoded `feed_url=`     | **Добавить** новый rss канал |


# Тестовое задание RSS parser

Необходимо спроектировать два микросервиса. Один для фоновой синхронизации данных о статьях с помощью **rss** лент. Второй для предоставления **HTTP** сервера с **RESTAPI**.

## Часть 1. Хранение данных и работа с БД.

Поднять **Postgres** в **docker** и описать запросы **DDL** для создания таблиц, где будут храниться списки доступных лент **rss**, статей с них и пользователей нашего "приложения". 

Изначально записать в таблицу доступных лент rss около 10-20 ссылок на ленты с которых будем получать информацию о статьях. 
К примеру: можно взять dtf (пример: https://dtf.ru/rss/) статьи Retail.ru (https://www.retail.ru/rss/articles/) и другие, их можно найти в интернете. 

Далее нужно создать worker, который будет кешировать источники **rss** (ссылки, которые представлены в примерах) к себе в память раз в **N время**. 

Также нужно создать worker, который бы брал **M источников RSS** (где M > 1 и <= кол-во источников RSS) и получал от туда данные об items (статьях или новостях) и писал их в БД со статусом не прочитано, если данная статья уже есть в БД и дата публикации у нее больше чем, то что в БД, то статью надо перезаписать.

## Часть 2. Реализация сервера с REST-API

- Написать HTTP сервер который бы имел методы: Добавлять новые rss источники. Доступно только администратору под авторизацией (В роли авторизации будет выступать uuid, который надо отправить в Header X-Auth-ID) 

- Получать список доступных rss лент. Доступно пользователям и Администраторам

- Подписываться на существующие rss ленты, которые доступны в сервисе. Доступно пользователям (В роли авторизации будет выступать uuid, который надо отправить в Header X-Auth-ID и сравнить, что такой пользователь с таким паролем-uuid, уже существует) 

- Отписываться от rss лент на которые подписан пользователь. В таком случае убирать запись о том, что статьи с подписанной ленты новые для данного пользователя и не показывать новости из таких статей пользователю. 

- Получать список статей (новостей) с ссылками на них с подписанных rss лент. При получении новых статей обозначать их прочитанными для пользователя. Можно реализовать с помощью записи последнего времени просмотра новостей пользователем.

## Задачи со звездочкой

1. Создать и описать make файл для запуска сервиса с помощью docker-compose (postgres и сам сервис) 

2.  Реализовать worker из первой части так, чтобы сразу два инстанса воркера могли работать параллельно, и не обрабатывали одновременно одни и те же rss ленты